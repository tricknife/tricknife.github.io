<!DOCTYPE html>
<html lang="en"><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <style>
        :root {
            --accent-color: #FF4D4D;
        }
    </style>

    
    
    
    
    
    

    
    <title>初识：Docker</title>
    <meta name="description" content="介绍 Docker 相关概念">
    <meta name="keywords" content='blog, gokarna, hugo, docker, 初识系列'>

    <meta property="og:url" content="https://tricknife.github.io/posts/%E5%88%9D%E8%AF%86docker/">
    <meta property="og:type" content="website">
    <meta property="og:title" content="初识：Docker">
    <meta property="og:description" content="介绍 Docker 相关概念">
    <meta property="og:image" content="/images/avatar.png">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="初识：Docker">
    <meta name="twitter:description" content="介绍 Docker 相关概念">
    <meta property="twitter:domain" content="https://tricknife.github.io/posts/%E5%88%9D%E8%AF%86docker/">
    <meta property="twitter:url" content="https://tricknife.github.io/posts/%E5%88%9D%E8%AF%86docker/">
    <meta name="twitter:image" content="/images/avatar.png">

    
    <link rel="canonical" href="https://tricknife.github.io/posts/%E5%88%9D%E8%AF%86docker/" />

    <link rel="stylesheet" type="text/css" href="https://tricknife.github.io//css/normalize.min.css" media="print" onload="this.media='all'">
    <link rel="stylesheet" type="text/css" href="https://tricknife.github.io//css/main.css">
    <link disabled id="dark-theme" rel="stylesheet" href="https://tricknife.github.io//css/dark.css">

    <script src="https://tricknife.github.io//js/svg-injector.min.js"></script>
    <script src="https://tricknife.github.io//js/feather-icons.min.js"></script>
    <script src="https://tricknife.github.io//js/main.js"></script>

    
    
        <!-- KaTeX -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css" integrity="sha384-Xi8rHCmBmhbuyyhbI88391ZKP2dmfnOl4rT9ZfRI7mLTdk1wblIUnrIq35nqwEvC" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js" integrity="sha384-X/XCfMm41VSsqRNQgDerQczD69XqmjOOOwYQvr/uuC+j4OPoNhVgjdGFwhvN02Ja" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"></script>
    <script>
      document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          // customised options
          // • auto-render specific keys, e.g.:
          delimiters: [
            {left: '$$', right: '$$', display: true},
            {left: '$', right: '$', display: false},
          ],
          // • rendering keys, e.g.:
          throwOnError : false
        });
      });
    </script>
  
    
</head>
<body>
        <script type="text/javascript">
            
            setThemeByUserPref();
        </script><header class="header">
    <nav class="header-nav">

        
        <div class="avatar">
            <a href="https://tricknife.github.io/">
                <img src="https://tricknife.github.io//images/avatar.png" alt="avatar" />
            </a>
        </div>
        

        <div class="nav-title">
            <a class="nav-brand" href="https://tricknife.github.io/">triknife</a>
        </div>

        <div class="nav-links">
            
            <div class="nav-link">
                <a href="https://tricknife.github.io/"><span data-feather='home'></span> Home </a>
            </div>
            
            <div class="nav-link">
                <a href="https://tricknife.github.io/posts/"><span data-feather='book'></span> Posts </a>
            </div>
            
            <div class="nav-link">
                <a href="https://tricknife.github.io/projects/"><span data-feather='code'></span> Projects </a>
            </div>
            
            <div class="nav-link">
                <a href="https://tricknife.github.io/tags/"><span data-feather='tag'></span> Tags </a>
            </div>
            
            <div class="nav-link">
                <a href="https://github.com/tricknife"><span data-feather='github'></span>  </a>
            </div>
            
            <div class="nav-link">
                <a href="https://tricknife.github.io/index.xml"><span data-feather='rss'></span>  </a>
            </div>
            

            <span class="nav-icons-divider"></span>
            <div class="nav-link dark-theme-toggle">
                <span id="dark-theme-toggle-screen-reader-target" class="sr-only"></span>
                <a>
                    <span id="theme-toggle-icon" data-feather="moon"></span>
                </a>
            </div>

            <div class="nav-link" id="hamburger-menu-toggle">
                <span id="hamburger-menu-toggle-screen-reader-target" class="sr-only">menu</span>
                <a>
                    <span data-feather="menu"></span>
                </a>
            </div>

            
            <ul class="nav-hamburger-list visibility-hidden">
                
                <li class="nav-item">
                    <a href="https://tricknife.github.io/"><span data-feather='home'></span> Home </a>
                </li>
                
                <li class="nav-item">
                    <a href="https://tricknife.github.io/posts/"><span data-feather='book'></span> Posts </a>
                </li>
                
                <li class="nav-item">
                    <a href="https://tricknife.github.io/projects/"><span data-feather='code'></span> Projects </a>
                </li>
                
                <li class="nav-item">
                    <a href="https://tricknife.github.io/tags/"><span data-feather='tag'></span> Tags </a>
                </li>
                
                <li class="nav-item">
                    <a href="https://github.com/tricknife"><span data-feather='github'></span>  </a>
                </li>
                
                <li class="nav-item">
                    <a href="https://tricknife.github.io/index.xml"><span data-feather='rss'></span>  </a>
                </li>
                
                <li class="nav-item dark-theme-toggle">
                    <span id="dark-theme-toggle-screen-reader-target" class="sr-only">theme</span>
                    <a>
                        <span id="theme-toggle-icon" data-feather="moon"></span>
                    </a>
                </li>
            </ul>

        </div>
    </nav>
</header>
<main id="content">
    <div class="post container">
    <div class="post-header-section">
        <h1>初识：Docker</h1>
        <small role="doc-subtitle">介绍 Docker 相关概念</small>
        <p class="post-date">
            April 1, 2023
        </p>

        <ul class="post-tags">
        
            <li class="post-tag"><a href="https://tricknife.github.io/tags/docker">docker</a></li>
        
            <li class="post-tag"><a href="https://tricknife.github.io/tags/%E5%88%9D%E8%AF%86%E7%B3%BB%E5%88%97">初识系列</a></li>
        
        </ul>
    </div>

    <div class="post-content">
        <p>
            <h2 id="什么是-docker">什么是 Docker?</h2>
<p>要认识什么是 Docker, 首先需要了解一个概念：容器(container). 容器是一个标准的软件单元，它封装代码及其所有依赖项，以便应用程序从一个计算环境快速可靠地运行到另一个环境。容器将软件与其环境隔离开来，使得软件可以在不同的环境工作一致，不用再费心环境与依赖。</p>
<p>而 Docker 就是一个开源的应用容器引擎，它可以创建容器以及基于容器运行的程序，广泛应用于 PaaS 产品中。Docker 基于 Golang 开发，通过 Linux 内核的 cgroup，namespace，以及 OverlayFS 类的 Union FS 等技术，从文件系统、网络互联到对进程进行封装隔离（在主机上以一个沙盒进程的形式工作）等, 属于操作系统层面的虚拟化技术。</p>
<blockquote>
<p>容器在几十年前首次出现，早期版本有 FreeBSD Jails 和 AIX Workload Partitions，但大多数现代开发人员都认为 2013 年 Docker的出现开启了现代容器时代。</p>
</blockquote>
<p>OpenStack、Cloudstack 这样的技术是解决IAAS层的问题，而容器技术的诞生其实主要解决了PAAS的层的技术实现。</p>
<h3 id="虚拟化虚拟机容器化容器">虚拟化，虚拟机，容器化，容器？</h3>
<p>Docker 是内核级，操作系统层次的虚拟化技术，这里涉及到两个名词：操作系统和虚拟化。</p>
<p><strong>操作系统</strong>就是管理计算机的硬件软件和资源，是覆盖在硬件上的第一层软件，并且为软件运行提供通用服务的系统软件，它的功能包括：</p>
<ul>
<li>硬件管理，包括分配CPU时间、内存；从网络、存储设备等IO设备读写数据。</li>
<li>软件管理，软件的运行，线程、进程调度等。</li>
<li>为软件提供运行环境，这个运行环境通常一部分由操作系统内核(Kernel, 是计算机硬件与其进程之间的核心接口) 提供，另一部分由运行库(Runtime Library) 提供。</li>
</ul>
<p>虚拟化 (Virtualization) 是一个通用的概念，是一种资源管理技术。是指将计算机的各种实体资源，如服务器、网络、内存及存储等，予以抽象、转换后呈现出来，打破实体结构间的不可切割的障碍，使用户可以用比原本的组态更好的方式来应用这些资源。</p>
<p>基于软件的虚拟化对象所在的层次，又可以分为应用虚拟化和平台虚拟化（容器和虚拟机即属于这个范畴）。前者指的是一些模拟设备比如 Wine， 后者可以分为以下子类：</p>
<ul>
<li>完全虚拟化。虚拟机模拟完整的底层硬件环境和特权指令的执行过程，客户操作系统(Guest OS) 无需修改。如 VirtualBox、 VMware Workstatio 等。</li>
<li>硬件辅助虚拟化。利用硬件（主要是CPU）辅助支持处理敏感指令来实现完全虚拟化的功能，客户操作系统无需修改。如KVM.</li>
<li>部分虚拟化。只对部分硬件资源进行虚拟化，客户操作系统需要进行修改。</li>
<li>超虚拟化(paravirtualization)。部分硬件接口以软件的形式提供给客户机操作系统，客户操作系统需要进行修改。</li>
<li>操作系统级虚拟化。内核通过创建多个虚拟的操作系统实例（内核和库）来隔离不同的进程。容器相关技术就属于这个范畴。</li>
</ul>
<p>虚拟机的虚拟化技术通常是指使用软件，在<strong>计算机硬件</strong>上创建一个抽象层，能够将单台计算机的硬件元素（处理器、内存、存储等）分成多个虚拟计算机（虚拟机）。每个虚拟机都会运行自己的操作系统（Guest OS），其行为就像一台独立的计算机，即使它只在一部分实际底层计算机硬件上运行。</p>
<p><img src="/images/dockerandvm2.png" alt="VM"></p>
<p>物理资源的虚拟化由 Hypervisor 来实现，有两种类型，感兴趣可以自行了解。它处于计算机物理层和虚拟机之间，能够管理计算机的物理资源并分配给不同的虚拟环境，既可以运行在操作系统上，也可以直接安装在硬件上。</p>
<p>虚拟化可以更高效地利用物理计算机硬件，提高组织在硬件投资方面的投资回报率，可以说虚拟化技术是云计算的根基。云计算供应商可以利用这项技术为客户提供一系列服务，包括：</p>
<ul>
<li>基础架构即服务 (IaaS)：可根据需求配置的虚拟化服务器、存储和网络资源。</li>
<li>平台即服务 (PaaS)：虚拟化的开发工具、数据库和其他基于云的服务，可用于构建您自己的基于云的应用和解决方案。</li>
<li>软件即服务 (SaaS)：在云端使用的软件应用。 SaaS 是从硬件进行最大程度抽象的基于云的服务。</li>
</ul>
<p>服务器虚拟化在硬件中重现整台计算机，然后运行整个操作系统，再由操作系统运行一个应用。这比完全没有虚拟化更有效，但它仍然为运行的每个应用复制不必要的代码和服务。而容器则采用了另一种方法。它们<strong>共享底层操作系统内核</strong>，仅运行应用及其依赖的内容，如软件库和环境变量。容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟，这使得容器体量更小，部署速度更快。</p>
<p>容器通过操作系统虚拟化形式，利用操作系统的功能（在 Linux 内核中，即名称空间和 cgroups 原语）来隔离进程，并<strong>控制这些进程有权访问的 CPU、内存和磁盘的数量</strong>，进程之间彼此隔离不会互相影响。容器体积小、速度快且可移植，与虚拟机不同，容器不需要在每个实例中都包含客户机操作系统（Guest OS），只需利用主机操作系统的功能和资源。</p>
<p><strong>容器化</strong>是将软件代码与操作系统库和依赖项所需的运行代码打包在一起，最终会获得一个之后可在容器平台上运行的容器镜像（image）。容器化应用包括打包应用及其相关的环境变量、配置文件、库和软件依赖关系。容器化使开发人员能够更迅速、更安全地创建和部署应用。</p>
<p><img src="/images/dockerandvm1.png" alt="VM">
总结一下：</p>
<ul>
<li>
<p>Hypervisor 是硬件虚拟化（Hardware Virtualization）——Hypervisor 将硬件物理资源划分为虚拟资源。</p>
</li>
<li>
<p>容器是操作系统虚拟化（OS Virtualization）——容器将系统资源划分为虚拟资源。</p>
</li>
</ul>
<p>与虚拟机相对比，容器的主要优点，在于提供了一种抽象级别，使其轻量且可移植：</p>
<ul>
<li>轻量：更快更小。容器共享计算机操作系统内核，无需为每个应用程序提供完整的操作系统实例（Guest OS），容器文件小并且资源易于使用，只打包了必要的Bin/Lib. 它们的体积更小，尤其是与虚拟机相比，这意味着可以快速运行，更好地支持横向扩展的云原生应用程序。</li>
<li>可移植且平台独立：容器包含所有的依赖关系，这意味着软件在一次编写后即可运行，无需在开发环境、云环境和本地计算环境中重新配置。</li>
<li>支持现代开发与架构：由于融入跨平台部署的可移植性/一致性以及体积小，容器非常适用于现代开发和应用模式，如 DevOps、 无服务器和微服务，它们都基于小增量常规代码部署而构建。</li>
<li>利用率高：与之前的虚拟机相同，容器可使开发人员和操作人员提高物理机的 CPU 和内存利用率。容器的进步之处在于，它们还支持微服务架构，因此可以更精细地部署和扩展应用组件。</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>VM（传统虚拟化技术）</th>
<th>容器虚拟化技术</th>
</tr>
</thead>
<tbody>
<tr>
<td>隔离</td>
<td>隔离度高（操作系统级）</td>
<td>容器间隔离度为进程级。</td>
</tr>
<tr>
<td>性能</td>
<td>启动速度慢（分钟级）</td>
<td>启动速度快（秒级）</td>
</tr>
<tr>
<td>存储</td>
<td>占用存储资源多（GB级）</td>
<td>占用存储资源少（KB级或MB级）</td>
</tr>
<tr>
<td>实践</td>
<td>使用方便（类似物理机）</td>
<td>更快交付与部署</td>
</tr>
<tr>
<td>依赖</td>
<td>虚拟化技术依赖的是物理CPU和内存，是硬件级别的</td>
<td>构建在操作系统层面的，利用操作系统的容器化技术，所以 Docker 同样的可以运行在虚拟机上面。</td>
</tr>
<tr>
<td>状态</td>
<td>传统的虚拟化技术是通过快照来保存状态的</td>
<td>Docker 引入了类似于源码管理的机制，将容器的快照历史版本一一记录下来，切换成本非常之低</td>
</tr>
<tr>
<td>构建</td>
<td>传统虚拟化技术在构建系统的时候非常复杂</td>
<td>可以通过一个简单的 Dockerfile 文件来构建整个容器，更重要的是 Dockerfile 可以手动编写，这样应用程序开发人员可以通过发布 Dockerfile 来定义应用的环境和依赖，这样对于持续交付非常有利。</td>
</tr>
<tr>
<td>其他</td>
<td>可以在一台计算机上创建多个虚拟机，每个虚拟机都拥有独立的操作系统</td>
<td>在一台计算机上可以运行上千个容器，这是容器技术对虚拟机的碾压式优势。</td>
</tr>
</tbody>
</table>
<p>更详细的可以见这份报告：<a href="https://www.ibm.com/downloads/cas/VG8KRPRM">IBM</a></p>
<h3 id="我听说过lxc-这是什么">我听说过LXC, 这是什么？</h3>
<p>Docker 技术最初是基于 LXC 技术构建（大多数人会将这一技术与&quot;传统的&quot;Linux 容器联系在一起），但后来它逐渐摆脱了对这种技术的依赖。LXC 可用作轻量型虚拟化技术，但它对开发人员和用户来说体验不甚理想。除了运行容器之外，Docker 技术还具备其他多项功能，包括简化用于构建容器、传输镜像以及控制镜像版本的流程。</p>
<p>传统的 Linux 容器使用 init 系统来管理多种进程。这意味着，所有应用都作为一个整体运行。与此相反，Docker 技术力争让应用各自独立运行其进程，并提供相应工具，帮助实现这一功能。这种精细化运作模式自有其优势。</p>
<h3 id="docker-能给我的服务带来什么">Docker 能给我的服务带来什么？</h3>
<p>Docker 的构想是要实现 &ldquo;Build Ship and Run Any App, Anywhere&rdquo;, 也就是通过对应用的封装(packaging)、 分发(Distribution)、 部署(Deployment)、 运行(Runtime) 声明周期进行管理，从而达到应用组件级别的一次封装，到处运行。这里的应用组件，既可以是一个 Web 应用，编译环境，也可以是一套数据库平台服务，甚至一个操作系统或集群。</p>
<p>结合上述容器化的一些优越之处，我们可以知道，Docker 可以帮助我们的服务：</p>
<ul>
<li>更快的交付和部署。利用 Docker, 开发人员可以快速构建一套标准的开发环境，从而测试和运维人员可以使用完全相同的环境来部署代码。只要开发测试过的代码，就可以确保在生产环境无差异地运行。并且，Docker 可以快速的创建和删除容器，实现快速迭代，节约开发、测试和部署的时间。</li>
<li>更轻松的迁移和扩展。Docker 几乎可以在任意平台运行，包括物理机、虚拟机、公有云、私有云、PC等，支持主流的操作系统发新版本，拥有极高的兼容性，因此可以在不同平台之间快速地迁移应用。</li>
<li>更简单的更新管理。使用 Dockerfile, 只需要对配置进行修改，就可以替代以往大量的更新工作。所有的修改都以增量的方式被分发和更新，从而实现自动化、标准化且高效的容器管理。</li>
<li>更高效的资源利用。Docker 容器不需要额外的虚拟化管理程序的支持，由于是内核级别的虚拟化，拥有更高的性能，对资源的额外需求很低。</li>
<li>模块化。Docker 容器化方法注重在不必停止整个应用的情况下，单独提取部分应用进行更新或修复的能力。除了这种基于微服务的方法，您还可以采用与面向服务的架构（SOA）类似的方法，在多个应用间共享进程。</li>
<li>层和镜像版本控制。每个 Docker 镜像文件都包含多个层，它们组合成一个镜像。每当镜像发生改变时，就会创建一个新的镜像层。每当用户指定命令时，例如 run 或 copy，就会创建一个新的层。Docker 可重复利用这些层来构建新容器，因而加快了构建过程。镜像之间共享中间变化，进一步提升了速度、规模以及效率。版本控制也是层所固有的功能：每次发生新的更改时，都会获得一个内置的更改日志，从而拥有对容器镜像的全盘管控。</li>
<li>回滚。回滚也许是层最值得一提的功能。每个镜像有多个层。不喜欢镜像的当前迭代可以直接将它回滚到上一版本。这一功能还支持敏捷开发方法，帮助实现持续集成和部署（CI/CD）。</li>
</ul>
<h2 id="那么-docker-以怎样的形式存在呢">那么 Docker 以怎样的形式存在呢？</h2>
<p>Docker 是一个开源的应用容器引擎，本质上就是一个程序。它的架构如图：</p>
<p><img src="/images/architecture.svg" alt="docker架构"></p>
<p>可以看出 Docker 是一个 client-server 的架构，使用者通过客户端 A command line interface (CLI) client 与守护进程 dockerd 进行交互，后者负责构建、运行和分发 Docker 容器。而客户端与服务端之间可以通过 REST API 进行交互，也能通过 UNIX 套接字或者网络接口，客户端可以和服务端部署在同一个系统上，也能远程连接。除了架构图里的 Client, 还有一种叫做 Docker Compose, 它可以运行由一系列的容器组合成的应用程序。</p>
<p>简单地了解一下相关的组件与概念：</p>
<ul>
<li>Docker deamon: 守护进程 <code>dockerd</code> 会监听 Docker API 请求并且管理 Docker 相关的资源对象：镜像(image)、容器(container)、网络(network) 和数据卷(volume).  Docker 服务的启动实际上是调用了 <code>dockerd</code> 命令。</li>
<li>Docker Host: 运行了 Docker deamon 的宿主机。</li>
<li>Client: 客户端 <code>docker</code> 是和 Docker 引擎进行交互（包括远程或与多个守护进程 <code>dockerd</code>）的主要方式。我们可以使用命令如 <code>docker run</code>, 客户端会将命令通过 Docker API 发送给 <code>dockerd</code>, 由 <code>dockerd</code> 执行。</li>
<li>Docker Objects: Docker 所管理的对象。当使用 Docker 的时候，实际上就是对这些对象进行操作，所有 Docker 的功能以及周边生态都围绕它们展开。
<ul>
<li>images : 镜像，核心概念之一。是一个只读的模板，也是创建容器的基础，它必须包含运行应用程序所需的所有东西——基本的操作系统、所有依赖项、配置、脚本、二进制文件等等。该映像还包含容器的其他配置，例如环境变量、要运行的默认命令和其他元数据。它是服务和容器之间的桥梁，我们可以把服务制作成镜像，基于镜像生成容器。镜像的制作同时往往是基于一些基础镜像，如 ubuntu 系统，或者是 go1.20 环境。制作镜像我们需要编写一个 Dockerfile 来指示制作过程。</li>
<li>containers : 容器，核心概念之一。容器就是根据镜像模板创建运行的实例，是一个与其他主机进程隔离的进程，我们可以通过 Docker 客户端对它的创建、启停、删除等进行管理。</li>
<li>volumes : 数据卷。数据卷是可供容器使用的特殊目录，将主机的操作系统目录直接映射进容器。当容器实例被删除时，对它的状态所进行的更改都会消失，所以对于需要持久化的数据，我们需要给它配置数据卷，将容器内的数据映射到主机环境中。</li>
<li>network : 网络。给容器配置网络，以提供外部访问容器或容器互联的服务。</li>
</ul>
</li>
<li>Registry : 仓库注册服务器。是集中存放镜像仓库的地方，可以分为公共仓库和私有仓库。官方的仓库叫 Docker Hub.</li>
</ul>
<h3 id="image">image</h3>
<p>镜像是非常重要的对象, 可以简单理解为环境+程序，通过 <code>image</code> 子命令来管理。 使用 <code>docker image ls</code> 可以列出本地主机上已经存在的顶层镜像，每个镜像都有一个唯一的镜像ID，我们可以看到有以下几个数据：</p>
<ul>
<li>REPOSITORY: 镜像来自于哪个仓库。仓库名、标签均为 <code>&lt;none&gt;</code> 的镜像被称为虚悬镜像，是由于新旧镜像同名，旧镜像名称被取消而出现的。</li>
<li>TAG: 镜像的标签。用来标记镜像的不同版本等。</li>
<li>IMAGE ID: 镜像的唯一ID。</li>
<li>SIZE: 所占用的空间</li>
</ul>
<p>给同一个 IMAGE ID 的镜像不同的标签，会在列表中看到多条记录。我们通常要用 <code>tag</code> 命令将构建的镜像改为：{namespace}/{镜像名}:{tag} 格式，再将其推送至 {namespace}/{镜像名} 仓库中。</p>
<p>有多种方式可以获得镜像：从远程拉取、基于 Dockerfile 制作、基于一个容器提交(commit)、从压缩包中导入等，其中最主要的还是基于 Dockerfile 制作。</p>
<p>镜像，有一个重要的概念——<strong>分层(layer)</strong>.</p>
<p>说镜像是 read-only template with instructions,  这是因为 Docker 的镜像并不是独立的二进制块，是由一层一层的文件系统组成（镜像层），所有的 Docker 镜像都起始于一个基础镜像层，当进行修改或增加新的内容时，就会在当前镜像层之上，创建一个新的镜像层（如果我们将多个命令合并在一条中，那么也只会生成一层）。可以使用 <code>docker history</code> 查看镜像的构建历史。在进行 <code>docker pull</code> 下载镜像的时候，通过脚本运行过程也可以看到镜像是分层下载并解压的。</p>
<p>下载过程中给出了每一层的 ID 的前 12 位。并且下载结束后，给出该镜像完整的 <code>sha256</code> 的摘要，以确保下载一致性。</p>
<p>容器销毁时，数据也会随之丢失，这是因为：当我们运行一个新的容器的时候，实际上是在镜像顶部新添加了一层 container layer 容器层。之后所有容器运行时对文件系统产生的修改实际都只影响这一层。删除容器后，可写层也会被删除。基础镜像保持不变。所以说在使用docker的过程中，<strong>在需要修改运行时容器文件数据的时候，尽量去重新构建镜像而不是直接修改容器内文件。如果重构镜像解决不了的问题，使用数据卷。</strong></p>
<p><img src="/images/container-layers.jpg" alt="container-layer"></p>
<p>因为每个容器都有其自己的可写容器层，并且所有更改都存储在该容器层中，所以多个容器可以共享对同一基础镜像的访问，但具有自己的数据状态。</p>
<p>对于运行时的容器而言，镜像层只读的，容器层可读也可写。对于镜像层的只读文件，容器层如果想做修改，实际上是进行了<strong>写时复制</strong>操作。写时复制是一种共享和复制文件的策略，可最大程度地提高效率。如果文件或目录位于镜像的较低层中，而另一层（包括可写层）需要对其进行读取访问，则它仅使用现有的已经存在的文件。另一层第一次需要修改文件时(在构建镜像或运行容器时)，将文件复制到该层并进行修改。这样可以将I/O和每个后续层的大小最小化。</p>
<p><img src="/images/sharing-layers.jpg" alt="sharing-layers"></p>
<p>我们也容易理解，采用分层的设计，会带来哪些好处：</p>
<ul>
<li>拉取更快：只需要拉取不存在的分层。</li>
<li>存储更少：资源共享，共用的层只需要存储一次，有利于大规模部署。</li>
<li>运行时存储更少：容器运行时可以共享相同的层。</li>
</ul>
<p>再理解一下查看容器的两个大小属性：</p>
<ul>
<li>size：用于每个容器的可写层的数据量（在磁盘上）。</li>
<li>virtual size：容器使用的只读镜像数据的数据量加上容器的可写层大小。多个容器可以共享部分或全部只读镜像数据。从同一镜像开始的两个容器共享100％的只读数据，而具有不同镜像的两个容器（具有相同的层）共享这些公共层。</li>
</ul>
<h3 id="registry-和-repository">registry 和 repository</h3>
<p>repository 是仓库，registry 是注册服务器，注册服务器就是存放仓库的具体服务器，是一个集中的存储、分发镜像的服务，它们的关系可以类比 Github 与 Project. 大部分时候，并不需要严格区分这两者的概念。仓库可以被认为是一个具体的项目，一个仓库通常集中存放一类镜像，用 tag 进行区分，比如 ubuntu:16.04、ubuntu:18.04.</p>
<pre tabindex="0"><code>注册服务器（Registry）
├─Repository（共有仓库）
│  ├─镜像1
│  ├─镜像2
│  ├─...更多镜像
├─Repository（私有仓库）
│  ├─镜像3
│  ├─镜像4
│  ├─...更多镜像
</code></pre><p>Docker Hub 是官方提供的最大的公共镜像仓库（其实就是指 Registry）, 当我们创建了自己的镜像后，就可以将其推送到 Docker Hub 的镜像仓库里，在需要的时候拉取。当然我们也可以拉取别人公开的一些镜像，方便的使用对应的服务。 不过就像使用 Github, 你也需要去 <a href="https://hub.docker.com/">Docker Hub</a> 注册账号，通过 <code>docker login</code> 来登陆，登陆成功即可将自己制作的镜像推送到 Docker Hub.</p>
<p>镜像仓库分为三个层级，分别是<strong>命名空间、镜像仓库和标签</strong>。 一个命名空间可以包含多个镜像仓库，一个镜像仓库下可以包含多个标签，每个标签对应一个镜像。</p>
<p>仓库有如下几种不同的形式：</p>
<ul>
<li>用户镜像仓库：由 Docker Hub 的注册用户创建并维护，镜像仓库通常会加上用户名作为 namespace: {username}/{镜像名}, 用户名就是默认的命名空间，这个命名空间是用来区分 Docker Hub 上注册的不同用户或者组织（类似于 GitHub 上用户名的作用）。</li>
<li>基础镜像（根镜像）仓库：如果不给出用户名，则默认为 <code>library</code>，也就是官方镜像。 如 centos, 这些仓库由官方提供，往往直接用镜像名作为仓库名。</li>
<li><code>[hub.c.163.com/library/nginx] </code> 这种指定路径的方式，一般用于非 Docker Hub 上的镜像命名，例如一个第三方服务商提供的镜像或者开发者自己搭建的镜像中心，都可以使用这种命名方式命名。</li>
</ul>
<p>Docker 将 Registry 也制作成了镜像，这意味着我们可以搭建自己的注册服务器：<code>docker run -d -p 5000:5000 --restart=always --name registry registry</code>.</p>
<p>默认情况下，仓库会被创建在容器的 <code>/var/lib/registry</code> 目录下。你可以通过 <code>-v</code> 参数来将镜像文件存放在本地的指定路径。例如下面的例子将上传的镜像放到本地的 <code>/opt/data/registry</code> 目录。</p>
<pre tabindex="0"><code>docker run -d \
    -p 5000:5000 \
    -v /opt/data/registry:/var/lib/registry \
    registry
</code></pre><p>对镜像的操作默认走的是 Docker Hub 仓库，我们可以通过将镜像标记为：宿主机ip地址:端口号/{镜像} 格式，这样就可以将其推送到 宿主机ip地址:端口号 所对应的私有仓库中了：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e">#将ubuntu:18.04 标记为 私有registry地址/镜像名</span>
</span></span><span style="display:flex;"><span>docker tag ubuntu:18.04 10.0.0.2:5000/test:latest
</span></span><span style="display:flex;"><span><span style="color:#75715e">#将这个镜像推送到 10.0.0.2:5000的test仓库里</span>
</span></span><span style="display:flex;"><span>docker push 10.0.0.2:5000/test
</span></span></code></pre></div><p>当然，更广泛的是使用国内的其他第三方镜像注册服务器，比如腾讯云、阿里云等，这些仓库里会保持 Docker Hub 中官方镜像的同步。</p>
<h3 id="volumes">volumes</h3>
<p>容器中的数据可以存储在容器层。但是将数据存放在容器层存在以下问题：</p>
<ul>
<li>数据不是持久化。意思是如果容器删除了，这些数据也就没了</li>
<li>主机上的其它进程不方便访问这些数据</li>
<li>对这些数据的I/O会经过存储驱动，然后到达主机，引入了一层间接层，因此性能会有所下降</li>
</ul>
<p><code>volume</code> 对象就是用来解决容器的数据存储问题。通过 <code>volume</code>子命令来管理。</p>
<p>数据卷是 Docker Objects 之一，它是一个可供一个或多个容器使用的特殊目录，绕过 UFS，可以提供很多有用的特性：</p>
<ul>
<li>可以在容器之间共享和重用</li>
<li>对数据卷的修改会立马生效</li>
<li>对数据卷的更新，不会影响镜像，解耦应用和数据</li>
<li>数据卷默认会一直存在，即使容器被删除</li>
</ul>
<blockquote>
<p>注意：数据卷的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会复制到数据卷中（仅数据卷为空时会复制）。</p>
</blockquote>
<p>我们可以通过命令直接操作这个对象：<code>docker volume create my-volume-object </code>。</p>
<p><code>数据卷</code> 是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除 <code>数据卷</code>，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的 <code>数据卷</code>。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 <code>docker rm -v</code> 这个命令。</p>
<p>数据卷有三种类型：</p>
<ol>
<li><code>volume</code> ：普通数据卷，存于主机文件系统中的某个区域，由Docker管理（<code>/var/lib/docker/volumes/</code>）。非Docker进程不应该修改这些数据。卷是Docker中持久化数据的最好方式.</li>
<li><code>bind mount</code> ：绑定数据卷，映射到主机文件系统中的任意位置。非Docker进程可以修改这些数据.</li>
<li><code>tmpfs mount</code>（Linux中）：临时数据卷，存于内存中（注意，并不是持久化到磁盘）。在容器的生命周期中，它能被容器用来存放非持久化的状态或敏感信息。</li>
</ol>
<p><img src="/images/volumetype.png" alt="volumetype"></p>
<p><code>bind mount</code> 和 <code>volume</code> 很相似，这二者都依赖于主机目录，但是区别在于volume是可docker的存储区域相关的，<code>bind mount</code> 是直接和操作系统相关的。</p>
<table>
<thead>
<tr>
<th>对比项</th>
<th>bind mount</th>
<th>volume</th>
</tr>
</thead>
<tbody>
<tr>
<td>Source位置</td>
<td>用户指定</td>
<td>/var/lib/docker/volumes/ （windows wsl2在 wsl 的目录中）</td>
</tr>
<tr>
<td>Source为空</td>
<td>覆盖dest为空</td>
<td>保留dest内容</td>
</tr>
<tr>
<td>Source非空</td>
<td>覆盖dest内容</td>
<td>覆盖dest内容</td>
</tr>
<tr>
<td>Source种类</td>
<td>文件或目录</td>
<td>只能是目录</td>
</tr>
<tr>
<td>可移植性</td>
<td>一般（自行维护）</td>
<td>强（docker托管）</td>
</tr>
<tr>
<td>宿主直接访问</td>
<td>容易（仅需chown）</td>
<td>受限（需登陆root用户）*</td>
</tr>
</tbody>
</table>
<h3 id="network">network</h3>
<p>另一个  Docker Object, 它是用来描述容器网络的对象，通过 <code>network</code> 子命令管理。</p>
<p>我们能够用它对各个容器之间的网络进行配置，还可以在容器之间建立虚拟网络，将数个容器包括在内，同时与其他网络环境隔离。</p>
<p>当安装 Docker 时，它会自动创建三个网络。你可以使用以下 <code>docker network ls</code> 命令列出这些网络。</p>
<pre tabindex="0"><code>docker network ls
NETWORK ID     NAME      DRIVER    SCOPE
c4e5387e6d5a   bridge    bridge    local
8242e40c766f   host      host      local
b0e73e522eee   none      null      local
</code></pre><p>运行容器时，可以使用该 <code>--network</code> 标志来指定容器应连接到哪些网络，默认会采用 bridge 模式。</p>
<p>可以在 <code>docker run</code> 运行一个容器的时候通过 <code>--net</code> 参数来指定容器的网络配置，有4个可选值：</p>
<ul>
<li><code>--net=bridge</code> 这个是默认值，连接到默认的网桥。</li>
<li><code>--net=host</code> 告诉 Docker 不要将容器网络放到隔离的命名空间中，即不要容器化容器内的网络。此时容器使用本地主机的网络，它拥有完全的本地主机接口访问权限。容器进程可以跟主机其它 root 进程一样可以打开低范围的端口，可以访问本地网络服务比如 D-bus，还可以让容器做一些影响整个主机系统的事情，比如重启主机。</li>
<li><code>--net=container:NAME_or_ID</code> 让 Docker 将新建容器的进程放到一个已存在容器的网络栈中，新容器进程有自己的文件系统、进程列表和资源限制，但会和已存在的容器共享 IP 地址和端口等网络资源，两者进程可以直接通过 <code>lo</code> 环回接口通信。</li>
<li><code>--net=none</code> 让 Docker 将新容器放到隔离的网络栈中，但是不进行网络配置。之后，用户可以自己进行配置。</li>
</ul>
<p>我们稍微了解一下 bridge 模式。</p>
<p>当 Docker 进程启动时，会在主机上创建一个名为 docker0 的虚拟网桥，此主机上启动的 Docker 容器会连接到这个虚拟网桥上。虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中。从docker0 子网中分配一个 IP 给容器使用，并设置 docker0 的 IP 地址为容器的<strong>默认网关</strong>。</p>
<p>默认情况下，当我们 <code>docker run</code> 运行容器时，容器不会向外界公开其任何端口。要使端口可用于 Docker 外部的服务，或可用于在不同网络上运行的 Docker 容器，需要使用 <code>--publish</code> or <code>-p</code> 标志来做端口映射，而这个过程 Docker 实际是在 <code>iptables</code> 做了 <code>DNAT</code> 规则，实现端口转发。</p>
<p><img src="/images/ovs-gre-docker.png" alt="ovs-gre-docker"></p>
<h2 id="如何将我的服务容器化">如何将我的服务容器化</h2>
<p>从上文我们已经知道，从服务到容器，中间的步骤是镜像，也就是说，实现容器化主要就是制作镜像。</p>
<p>以 Go 语言为例，如果想要实验可以下载官方的 demo: <code>git clone https://github.com/olliefr/docker-gs-ping</code>， 这是一个简单的 HTTP 服务，使用 8080 端口，开放了 <code>&quot;/&quot;</code> 和 <code>&quot;/health&quot;</code> 两个 GET API.</p>
<p>那么，首先我们将这个服务制作成镜像，这一步的核心是编写 Dockerfile 文件（这个项目里已经有了，也可以直接看自带的 Dockerfile 或 Dockerfile.multistage）. 编写 Dockerfile, 实际上就是将从代码到执行的流程记录下来。</p>
<p>在服务的根目录创建一个 <code>Dockerfile</code> 文件：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-dockerfile" data-lang="dockerfile"><span style="display:flex;"><span><span style="color:#75715e"># syntax=docker/dockerfile:1</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#75715e"># 代表注释</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#75715e">## Build</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#75715e"># 本阶段选择 golang:1.19 作为基础镜像，为我们提供编译环境。</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#75715e"># AS build 表示为这个构建阶段命名</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">FROM</span><span style="color:#e6db74"> golang:1.19 AS build</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#75715e"># 选择 /app 作为我们的工作目录，接下来的命令会以 /app 作为当前目录</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">WORKDIR</span><span style="color:#e6db74"> /app</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#75715e">## 为我们的 go 服务拉取依赖包</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#75715e"># 把 （服务的）go.mod 文件和 go.sum 文件拷贝到（镜像）的当前目录</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">COPY</span> go.mod ./<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">COPY</span> go.sum ./<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#75715e"># 基于golang:1.16-buster的环境</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">RUN</span> go mod download<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#75715e"># 将所有的 go 文件拷贝到当前目录</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">COPY</span> *.go ./<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#75715e"># 编译，在根目录生成 docker-gs-ping 目标</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">RUN</span> go build -o /docker-gs-ping<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#75715e">## 在 Docker 17.05 以上版本中，我们可以使用多阶段构建</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#75715e">## 上一阶段我们得到了编译后的文件，不再需要 go 环境与依赖包了，为了缩减镜像的体积，我们进入第二阶段的构建。</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#75715e">## Deploy</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">FROM</span><span style="color:#e6db74"> gcr.io/distroless/base-debian10</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">WORKDIR</span><span style="color:#e6db74"> /</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#75715e"># 将上一阶段的编译产物拷贝到该阶段镜像的根目录</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">COPY</span> --from<span style="color:#f92672">=</span>build /docker-gs-ping /docker-gs-ping<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#75715e"># 没有实际作用，仅仅是为了文档标记，说明需要开放容器的 8080 端口</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">EXPOSE</span><span style="color:#e6db74"> 8080</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">USER</span><span style="color:#e6db74"> nonroot:nonroot</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#75715e"># 当我们启动容器时，执行该命令，也就是运行编译后的 docker-ps-ping 文件</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">ENTRYPOINT</span> [<span style="color:#e6db74">&#34;/docker-gs-ping&#34;</span>]<span style="color:#960050;background-color:#1e0010">
</span></span></span></code></pre></div><p>进入服务的根目录，执行：<code>docker build -t docker-gs-ping:multistage .</code>, 这代表在当前目录(也就是 &ldquo;.&rdquo; 这个值)寻找 Dockerfile, 并且构建一个名为 dcoker-gs-ping 的镜像，这一版本的镜像，给它打上 multistage 的标签(tag).</p>
<p>如果想直接指定项目中的 Dockerfile.multistage, 可以使用：<code>docker build -t docker-gs-ping -f Dockerfile.multistage .</code></p>
<p>如果构建失败了，可以尝试添加代理重试。成功后，可以使用 <code>docker image ls</code> 命令查看。</p>
<p>那么接下来就简单了，<code>docker run -d -p 8080:8080 docker-gs-ping</code> 将容器的 8080 端口映射到主机的 8080 上，并且后台运行，我们可以通过访问 localhost 的 8080 端口来访问容器内的服务。运行后，可以用 <code>docker ps</code> 来查看正在运行的容器相关信息。</p>
<p>这个过程中涉及到许多没有提及的细节，比如上文说到的数据持久化，容器的网络设置，更具体的使用在下一篇中介绍。</p>
<h2 id="参考资料与推荐阅读">参考资料与推荐阅读</h2>
<ul>
<li><a href="https://www.docker.com/resources/what-container/">what is container</a></li>
<li><a href="https://www.ibm.com/cn-zh/topics/virtualization">什么是虚拟化</a></li>
<li>《Docker技术入门与实战 第3版》</li>
<li><a href="https://vuepress.mirror.docker-practice.com/">Docker — 从入门到实践</a></li>
</ul>

        </p>
        
    </div>

    <div class="prev-next">
        
    </div>
</div>

<aside class="post-toc">
    <nav id="toc">
        <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#什么是-docker">什么是 Docker?</a>
          <ul>
            <li><a href="#虚拟化虚拟机容器化容器">虚拟化，虚拟机，容器化，容器？</a></li>
            <li><a href="#我听说过lxc-这是什么">我听说过LXC, 这是什么？</a></li>
            <li><a href="#docker-能给我的服务带来什么">Docker 能给我的服务带来什么？</a></li>
          </ul>
        </li>
        <li><a href="#那么-docker-以怎样的形式存在呢">那么 Docker 以怎样的形式存在呢？</a>
          <ul>
            <li><a href="#image">image</a></li>
            <li><a href="#registry-和-repository">registry 和 repository</a></li>
            <li><a href="#volumes">volumes</a></li>
            <li><a href="#network">network</a></li>
          </ul>
        </li>
        <li><a href="#如何将我的服务容器化">如何将我的服务容器化</a></li>
        <li><a href="#参考资料与推荐阅读">参考资料与推荐阅读</a></li>
      </ul>
    </li>
  </ul>
</nav>
    </nav>
</aside>



    

        </main><footer class="footer">
    <span>&copy; 2023 no idea what to write as footer</span>
    <span>
    </span>
</footer>
</body>
</html>
